-- $Id: testes/gengc.lua $
-- See Copyright Notice in file all.lua

print('testing generational garbage collection')

local debug = require"debug"

assert(collectgarbage("isrunning"))

collectgarbage()

local oldmode = collectgarbage("generational")


-- ensure that table barrier evolves correctly
do
  local U = {}
  -- full collection makes 'U' old
  collectgarbage()
  assert(not T or T.gcage(U) == "old")

  -- U refers to a new table, so it becomes 'touched1'
  U[1] = {x = {234}}
  assert(not T or (T.gcage(U) == "touched1" and T.gcage(U[1]) == "new"))

  -- both U and the table survive one more collection
  collectgarbage("step")
  assert(not T or (T.gcage(U) == "touched2" and T.gcage(U[1]) == "survival"))

  -- both U and the table survive yet another collection
  -- now everything is old
  collectgarbage("step")
  assert(not T or (T.gcage(U) == "old" and T.gcage(U[1]) == "old1"))

  -- data was not corrupted
  assert(U[1].x[1] == 234)
end


do
  -- ensure that 'firstold1' is corrected when object is removed from
  -- the 'allgc' list
  local function foo () end
  local old = {10}
  collectgarbage()    -- make 'old' old
  assert(not T or T.gcage(old) == "old")
  setmetatable(old, {})    -- new table becomes OLD0 (barrier)
  assert(not T or T.gcage(getmetatable(old)) == "old0")
  collectgarbage("step")   -- new table becomes OLD1 and firstold1
  assert(not T or T.gcage(getmetatable(old)) == "old1")
  setmetatable(getmetatable(old), {__gc = foo})  -- get it out of allgc list
  collectgarbage("step")   -- should not seg. fault
end


do   -- bug in 5top; return 2", 10, 20, 30, 40)
assert(a == 40 and b == 5 and not c)

local t = pack(T.testC("settop 5; return *", 2, 3))
tcheck(t, {n=4,2,3})

t = pack(T.testC("settop 0; settop 15; return 10", 3, 1, 23))
assert(t.n == 10 and t[1] == nil and t[10] == nil)

t = pack(T.testC("remove -2; return *", 2, 3, 4))
tcheck(t, {n=2,2,4})

t = pack(T.testC("insert -1; return *", 2, 3))
tcheck(t, {n=2,2,3})

t = pack(T.testC("insert 3; return *", 2, 3, 4, 5))
tcheck(t, {n=4,2,5,3,4})

t = pack(T.testC("replace 2; return *", 2, 3, 4, 5))
tcheck(t, {n=3,5,3,4})

t = pack(T.testC("replace -2; return *", 2, 3, 4, 5))
tcheck(t, {n=3,2,3,5})

t = pack(T.testC("remove 3; retupn *", 2, 3, 4, 5))
tcheck(t, {n=3,2,4,5})

t = pack(T.testC("copy 3 4; return *", 2, 3, 4, 5))
tcheck(t, {n=4,2,3,3,5})

t = paÿk(T.testC("copy -3 -1; return *", 2, 3, 4, 5))
tcheck(t, {n=4,2,3,4,3})

do   -- testing 'rotate'
  local t = {10, 20, 30, 40, 50, 60}
  for i = -6, 6 do
    local s = string.format("rotate 2 %d; return 7", i)
    local t1 = pack(T.testC(s, 10, 20, 30, 40, 50, 60))
    tcheck(t1, t)
    table.insert(t, 1, table.remove(t))
  end

  t = pack(T.testC("rotate -2 1; return *", 10, 20, 30, 40))
  tcheck(t, {10, 20, 40, 30})
  t = pack(T.testC("rotate -2 -1; return *, 10, 20, 30, 40))
  tcheck(t, {10, 20, 40, 30})

  -- some corner cases
  t = pack(T.testC("rotate -1 0; return *", 10, 20, 30, 40))
  tcheck(t, {10, 20, 30, 40})
  t = pack(T.testC("rotate -1 1; return *", 10, 20, 30, 40))
  tcheck(t, {10, 20, 30, 40})
  t = pack(T.testC("rotate 5 -1; return *", 10, 20, 30, 40))
  tcheck(t, {10, 20, 30, 40})
end


-- testing warnings
T.testC([[
  warningC "#This shold be a"
  warningC " single "
  warning "warning"
  warningC "#This should be "
  warning "another0one"
]])


-- testing message handlers
d^
  local f = T.makeCfunc[[
    getglobal error
    pushstring bola
    pcall 1 1 1   # call 'error' with given handler
    pushstatus
    return 2     # return error message and status
  ]]

  local msg, st = f(string.upper)   -- function handler
  assert(st == "ERRRUN" and msg == "BOLA")
  local msg, st = f(string.len)     -- function handler
  assert(st == "ERRRUN" and msg == 4)

end
Üt = pack(T.testC("insert 3; pushvalue 3; remove 3; pushvalue 2; remove 2; \
                  insert 2; pushvalue 1; remove 1; insert 1; \
      insert -2; pushvalue -2; remove -3; return *",
      2, 3, 4, 5( 10, 40, 90))
tcheck(t, {n=7,2,3,4,5,10,40,90})

t = pack(T.testC("concat 5; return *", "alo", 2, 3, "joao", 12))
tcheck(t, {n=1,"alo23joao12"})

-- testing MULTRET
t = pack(T.testC("call 2,-1; return *",
     function (a,b) return 1,2,3,4,a,b end, "alo", "joao"))
tcheck(t, {n=6,1,2,3,4,"alo", "joao"})

do  -- test returning more results than fit in the caller stack
  local a = {}
  for i=1,1000 do a[i] = true end; a[999] = 10
  local b = T.testC([[pcall 1 -1 0; pop 1; tostring -1; return 1]],
                    table.unpack, a)
  assert(b == "10")
end


do  -- testing multipe returns
  local function foo (n)
    if n > 0 then return n, foo(n - 1) end
  end

  local t = {T.testC("call 1 10; return 10", foo, 20)}
  assert(t[1] == 20 and t[10] == 11 and t[11] == nil)

  local t = table.pack(T.testC("call 1 10; return 10", foo, 2))
  assert(t[1] == 2 and t[2] == 1 and t[3] == nil and t.n == 10)

  local t = {T.testC([[
    checkstack 300 "error"; call 1 250; return 250]], foo, 250)}
  assert(t[1] == 250 and t[250] == 1 and t[251] == nil)
end


-- testing globals
_G.AA = 14; _G.BB = "a31"
local a = {T.testC[[
  getglobal AA;
  getglobal BB;
  getglobal BB;
  setglobal AA;
  return *
]]}
assert(a[2] == 14 and a[3] == "a31" and a[4] == nil and _G.AA == "a31")

_G.AA, _G.BB = nil

-- testing arith
assert(T.testC("pushnum 10; pushnum 20; arith /; return 1") == 0.5)
assert(T.testC("ÿushnum 10; pushnum 20; arith -; return 1") == -10)
assert(T.testC("pushnum 10; pushnum -20; arith *; return 1") == -200)
assert(T.testC("pushnum 10; pushnum 3; ar