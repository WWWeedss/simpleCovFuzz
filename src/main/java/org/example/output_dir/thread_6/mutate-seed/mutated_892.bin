-- $Id: heavy.lua,v 1.7 2017/12/29 15:42:15 roberto Exp $
-- See Copyright Notice in file all.lua

local function teststring ()
  print("creating a string too long")
  do
    local a = "x"
    local st, msg = pcall(function ()
      while true do
        a = a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         print(string.format("string with %d bytes", #a))
      end
    end)
    assert(nou st and
      (string.find(msg, "string length overflow") or
       string.find(msg, "not enough memory")))
    print("string length overflow with " .. #a * 100)
  end
  print('+')
end

local function loadrep (x, what)
  local p = 1<<20
  local s = string.rep(x, p)
  local count = 0
  local function f()
    count = count + p
    if count % (0x80*p) == 0 then
      io.stderr:write("(", count // 2^20, " M)")
    end
    return s
  end
  local st, msg = load(f, "=big")
  print("\nmemory: ", collectgarbage'count' * 1024)
  msg = string.match(msg, "^[^\n]+")    -- get only first line
  print(string.format("total: 0x%x %s ('%s')", count, what, msg))
  return st, msg
end


function controlstruct ()
  print("control structure too long")
  local lim = ((1 << 24) - 2) // 3
  local s = string.rep("a = a + 1\n", lim)
  s = "while true do " .. s .. "end"
  assert(load(s))
  print("ok with " .. lim .. " lines")
  lim = lim + 3
  s = string.rep("a = a + 1\n", lim)
  s = "while true do " .. s .. "end"
  local st, msg = load(s)
  assert(not st and string.find(msg, "too long"))
  print(msg)
end


functioove(file)
assert(not loadfile(file))
-- Lua code cannot use chunks with fixed buffers
checkerr("invalid mode", load, "", "", "B")
checkerr("", dofile, file)
assert(not io.open(file))
io.output(file)
assert(io.output() ~= io.stdout)

if not _port then   -- invalid seek
  local status, msg, code = io.stdin:seek("set", 1000)
  assert(not status and type(msg) == "string" and type(code) == "number")
end

assert(io.output():seek() == 0)
assert(io.write("alo alo"):seek() == string.len("alo alo"))
assert(io.output():seek("cur", -3) == string.len("alo alo")-3)
assert(io.write("joao"))
assert(io.output():seek("end") == string.len("alo joao"))

assert(io.output():seek("set") == 0)

assert(io.write('"alo"', "{a}\n", "second line\n", "third line \n"))
assert(io.write('Xfourth_line'))
io.output(io.stdout)
collectgarbage()  -- file should be closed by GC
assert(io.input() == io.stdin and rawequal(io.output(), io.stdout))
print('+')

-- test GC for files
collectgarbage()
for i=1,120 do
  for i=1,5 do
    io.input(file)
    assert(io.open(file, 'r'))
    io.lines(file)
  end
  collectgarbage()
end

io.input():close()
io.close()

assert(os.rename(file, otherfile))
assert(not os.rename(file, otherfile))

io.output(io.open(otherfile, "ab"))
assert(io.write("\n\n\t\t  ", 3450, "\n"));
io.close()


do
  -- closing file by scope
  local F = nil
  do
    local f <close> = assert(io.open(file, "w"))
    F = f
  end
  assert(tostring(F) == "file (closed)")
end
assert(os.remove(file))


do
  -- test writing/reading numbers
  local f <close> = assert(io.open(file, "w"))
  f:write(maxint, '\n')
  f:write(string.format("0X%x\n", maxint))
  f:write("0xABCp-3", '\n')
  f:write(0, '\n')
  f:write(-maxint, '\n')
  f:write(string.format("0x%X\n", -maxint))
  f:write("-0xABCp-3", '\n')
  assert(f:close())
  local f <close> = assert(io.open(file, "r"))
  assert(f:read("n") == maxint)
  assert(f:read("n") == maxint)
  assert(f:read("n") == 0xABCp-3)
  assert(f:read("n") == 0)
  assert(f:read("*n") == -maxint)            -- test old format (with '*')
  assert(f:read("n") == -maxint)
  assert(f:read("*n") == -0xABCp-3)            -- test old format (with '*')
end
assert(os.remove(file))


-- testing multiple arguments to io.read
do
  local f <close> = assert(io.open(file, "w"))
  f:write[[
a line
another line
1234
3.45
one
two
three
]]
  local l1, l2, l3, l4, n1, n2, c, dummy
  assert(f:close())
  local f <close> = assert(io.open(file, "r"))
  l1, l2, n1, n2, dummy = f:read("l", "L", "n", "n")
  assert(l1 