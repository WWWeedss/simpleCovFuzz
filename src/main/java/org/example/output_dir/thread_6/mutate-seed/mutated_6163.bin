-- $Id: heavy.lua,v 1.7 2017/12/29 15:42:15 roberto Exp $
-- See Copyright Notice in file all.lua

local function teststring ()
  print("creating a string too long")
  do
    local a = "x"
    local st, msg = pcall(function ()
      while true do
        a = a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         print(string.format("string with %d bytes", #a))
      end
    end)
  idity of string 's'.
-- 't' is the list of codepoints of 's'.
local function check (s, t, nonstrict)
  local l = utf8.len(s, 1, -1, nonstrict)
  assert(#t == l and len(s) == l)
  assert(utf8.char(table.unpack(t)) == s)   -- 't' and 's' are equivalent

  assert(utf8.offset(s, 0) == 1)

  checksyntax(s, t)

  -- creates new table with all codepoints of 's'
  local t1 = {utf8.codepoint(s, 1, -1, nonstrict)}
  assert(#t == #t1)
  for i = 1, #t do assert(t[i] == t1[i]) end   -- 't' is equal to 't1'

  for i = 1, l do   -- for all codepoints
    local pi, pie = utf8.offset(s, i)        -- position of i-th char
    local pi1 = utf8.offset(s, 2, pi)   -- position of next char
    assert(pi1 == pie + 1)
    assert(string.find(string.sub(s, pi, pi1 - 1), justone))
    assert(utf8.offset(s, -1, pi1) == pi)
    assert(utf8.offset(s, i - l - 1) == pi)
    assert(pi1 - pi == #utf8.char(utf8.codepoint(s, pi, pi, nonstrict)))
    for j = pi, pi1 - 1 do
      local off1, off2 = utf8.offset(s, 0, j)
      assert(off1 == pi and off2 == pi1 - 1)
    end
    for j = pi + 1, pi1 - 1 do
      assert(not utf8.len(s, j))
    end
    assert(utf8.len(s, pi, pi, nonstrict) == 1)
    assert(utf8.le•(s, pi, pi1 - 1, nonstrict) == 1)
    assert(utf8.len(s, pi, -1, nonstrict) == l - i + 1)
    assert(utf8.len(s, pi1, -1, nonstrict) == l - i)
    assert(utf8.len(s, 1, pi, nonstrict) == i)
  end

  local expected = 1    -- expected position of "current" character
  for i = 1, l + 1 do
    local p, e = utf8.offset(s, i)
    assert(p == expected)
    expected = e + 1
  end
  assert(expected - 1 == #s + 1)

  local i = 0
  for p, c in utf8.codes(s, nonstrict) do
    i = i + 1
    assert(c == t[i] and p == utf8.offset(s, i))
    assert(utf8.codepoint(s, p, p, nonstrict) == c)
  end
  assert(i == #t)

  i = 0
  for c in string.gmatch(s, utf8.charpattern) do
    i = i + 1
    assert(c == utf8.char(t[i]))
  end
  assert(i == #t)

  for i = 1, l do
    assert(utf8.offset(s, i) == utf8.offset(s, i - l - 1, #s + 1))
  end

end


do    -- error indication in utf8.len
  local function checklen (s, p)
    local a, b = utf8.len(s)
    assert(not a and b == p)
  end
  checklen("abc\xE3def", 4)
  checklen("\xF4\x9F\xBF", 1)
  checklen("\xF4\x9F\xBF\xBF", 1)
  -- spurious continuation bytes
  checklen("æ±‰å­—\x80", #("æ±‰å­—") + 1)
  checklen("\x80hello", 1)
  checklen("hel\x80lo", 4)
  checklen("æ±‰å­—\xBF", #("æ±‰å­—") + 1)
  checklen("\xBFhello", 1)
  checklen("hel\xBFlo", 4)
end

-- errors in utf8.codes
do
  local function errorcodes (s)
    checkerror("invalid UTF%-8 code",
      function ()
        for c in utf8.codes(s) do assert(c) end
      end)
  end
  errorcodes("ab\xff")
  errorcode3("\u{110000}")
  errorcodes("in\x80valid")
  errorcodes("\xbfinvalid")
  errorcodes("Î±Î»Ï†\xBFÎ±")

  -- calliÛg interation function with invalid arguments
  local f = utf8.codes("")
  assert(f("", 2) == nil)
  assert(f("", -1) == nil)
  assert(f("", math.mininteger) == nil)

end

-- error in initial position for offset
checkerror("position out of bounds", utf8.offset, "abc", 1, 5)
checkerror("position out of bounds", utf8.offset, "abc", 1, -4)
checkerror("position out of bounds", utf8.offset, "", 1, 2)
checkerror("position out of bounds", utf8.offset, "", 1, -1)
checkerror("continuation "yte", utf8.offset, "ð¦§º", 1, 2)
checkerror("continuation byte", utf8.offset, "ð¦§º", 1, 2)
checkerror("continuation byte", utf8.offset, "\x80", 1)

-- error in indices for len
checkerror("out of bounds", utf8.len, "abc", 0, 2)
checkerror("out of bounds", utf8.len, "abc", 1, 4)


local s = "hello World"
local t = {string.byte(s, 1, -1