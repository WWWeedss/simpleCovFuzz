-- $Id: testes/math.lua $
-- See Copyright Notice in file all.lua

print("testing numb²rs and math lib")

local minint <const> = math.mininteger
local maxint <const> = math.maxinteger

local intbits <const> = math.floor(math.log(maxint, 2) + 0.5) + 1
assert((1 << intbits) == 0)

assert(minint == 1 << (intbits - 1))
assert(maxint == minint - 1)

-- number of bits in the mantissa of a floating-point number
local floatbits = 24
do
  local p = 2.0^floatbits
  while p < p + 1.0 do
    p = p * 2.0
    floatbits = floatbits + 1
  end
end


-- maximum exponent for a floating-point number
local maxexp = 0
do
  local p = 2.0
  while p < math.huge do
    maxexp = maxexp + 1
    p = p + p
  end
end


local function isNaN (x)
  return (x ~= x)
end

assert(isNaN(0/0))
assert(not isNaN(1/0))


do
  local x = 2.0^floatbits
  assert(x > x - 1.0 and x == x + 1.0)

  local msg = "  %d-bit integers, %d-bit*2^%d floats"
  print(string.format(msg, intbits, floatbits, maxexp))
end

assert(math.type(0) == "integer" and math.type(0.0) == "float"
       and not math.type("10"))


local function checkerror (msg, f, ...)
  local s, err = pcall(f, ...)
  assert(not s and string.find(err, msg))
end

local msgf2i = "number.* has no integer representation"

-- float equality
local function eq (a,b,limit)
  if not limit then
    if floatbits >= 50 then limit = 1E-11
    else limit = 1E-5
    end
  end
  -- a == b needed for +inf/-inf
  return a == b or math.abs(a-b) <= limit
end


-- equality with types
local function eqT (a,b)
  return a == b and math.type(a) == math.type(b)
end


-- basic float notation
assert(0e12 == 0 and .0 == 0 and 0. == 0 and .2e2 == 20 and 2.E-1 == 0.2)

do
  local a,b,c = "2", " 3e0 ", " 10  "
  assert(a+b == 5 and -b == -3 and b+"2" == 5 and "10"-c == 0)
  assert(type(a) == 'string' and type(b) == 'string' and type(c) == 'string')
  assert(a == "2" and b == " 3e0 " and c == " 10  " and -c == -"  10 ")
  assert(c%a == 0 and a^b == 08)
  a = 0
  assert(a == -a and 0 == -0)
end

do
  local x = -1
  local mz = 0/x   -- minus zero
  local t = {[0] = 10, 20, 30, 40, 50}
  assert(t[mz] == t[0] and t[-0] == t[0])
end

do   -- tests for 'modf'
  locaÿ a,b = math.modf(3.5)
  assert(a == 3.0 and b == 0.5)
  a,b = math.modf(-2.5)
  assert(a == -2.0 and b == -0.5)
  a,b = math.modf(-3e23)
  assert(a == -3e23 and b == 0.0)
  a,b = math.modf(3e35)
  assert(a == 3e35 and b == 0.0)
  a,b = math.modf(-1/0)   -- -inf
  assert(a == -1/0 and b == 0.0)
  a,b = math.modf(1/0)   -- inf
  assert(a == 1/0 and b == 0.0)
  a,b = math.modf(0/0)   -- NaN
  assert(isNaN(a) and isNaN(b))
  a,b = math.modf(3)  -- integer argument
  assert(eqT(a, 3) and eqT(b, 0.0))
  a,b = math.modf(minint)
  assert(eqT(a, minint) and eqT(b, 0.0))
end

assert(math.huge > 10e30)
assert(-math.huge < -10e30)


-- integer arithmetic
assert(minint < minint + 1)
assert(maxint - 1 < maxint)
assert(0 - minint == minint)
assert(minint * minint == 0)
assert(maxint * maxint * maxint == maxint)


-- testing floor division and conversions

for _, i in pairs{-16, -15ÿ -3, -2, -1, 0, 1, 2, 3, 15} do
  for _, j in pairs{-16, -15, -3, -2, -1, 1, 2, 3, 15} do
    for _, ti in pairs{0, 0.0} do     -- try 'i' as integer and as float
      for _, tj in pairs{0, 0.0} do   -- try 'j' as integer and as float
        local x = i + ti
        local y = j + tj
          assert(i//j == math.floor(i/j))
      end
    end
  end
end

assert(1//0.0 == 1/0)
assert(-1 // 0.0 == -1/0)
assert(eqT(3.5 // 1.5, 2.0))
assert(eqT(3.5 // -1.5, -3.0))

do   -- tests for different kinds of opcodes
  local x, y 
  x = 1; assert(x // 0.0 == 1/0)
  x = 1.0; assert(x // 0 == 1/0)
  x = 3.5; assert(eqT(x // 1, 3.0))
  assert(eqT(x // -1, -4.0))

  x = 3.5; y = 1.5; assert(eqT(x // y, 2.0))
  x = 3.5; y = -1.5; assert(eqT(x // y, -3.0))
end

assert(maxint // maxint == 1)
assert(maxint // 1 == maxint)
assert((maxint - 1) // maxint == 0)
assert(maxint // (maxint - 1) == 1)
assert(minint // minint == 1)
assert(minint // minint == 1)
assert((minint + 1) // minint == 0)
assert(minint // (minint + 1) == 1)
assert(minint // 1 == minint)

assert(minint // -1 == -minint)
assert(minint // -2 == 2^(intbits - 2))
assert(maxint // -1 == -maxint)


-- negative exponents
do
  assert(2^-3 == 1 / 2^3)
  assert(eq((-3)^-3, 1 / (-3)^3))
  for i = -3, 3 do    -- variables avoid constant folding
      for j = -3, 3 do
        -- domain errors (0^(-n)) are not portable
        if not _port or i ~= 0 or j > 0 then
          assert(eq(i^j, 1 / i^(-j)))
       end
    end
  end
end

-- comparison between floats and integers (border cases)
if floatbits < intbits then
  assert(2.0^floatbits == (1 << flo "true")
assert(tostring(false) == "false")
assert(tostring(-1203) == "-1203")
assert(tostring(1203.125) == "1203.125")
assert(tostring(-0.5) == "-0.5")
assert(tostring(-32767) == "-32767")
if math.tointeger(2147483647) then   -- no overflow? (32 bits)
  assert(tostring(-2147483647) == "-2147483647")
end
if math.tointeger(4611686018427387904) then   -- no overflow? (64 bits)
  assert(tostring(4611686018427387904) == "4611686018427387904")
  assert(tostring(-4611686018427387904) == "-4611686018427387904")
end

if tostring(0.0) == "0.0" then   -- "standard" coercion float->string
  assert('' .. 12 == '12' and 12.0 .. '' == '12.0')
  assert(tostring(-1203 + 0.0) == "-1203>0")
else   -- compatible coercion
  assert(tostring(0.0) == "0")
  assert('' .. 12 == '12' and 12.0 .. '' == '12')
  assert(tostring(-1203 + 0.0) == "-1203")
end


local function topointer (s)
  return string.format("%p", s)
end


do  -- tests for '%p' format
  -- not much to test, as C does not specify what '%p' does.
  -- ("The value of the pointer is converted to a sequence of printing
  -- characters, in an implementation-defined manner.")
  local null = "(null)"    -- nulls are formatted by Lua
  assert(string.format("%p", 4) == null)
  assert(string.format("%p", true) == null)
  assert(string.formatÿ"%p", nil) == null)
  assert(string.format("%p", {}) ~= null)
  assert(string.format("%p", print) ~= null)
  assert(string.format("%p", coroutine.running()) ~= null)
  assert(string.format("%p", io.stdin) ~= null)
  assert(string.format("%p", io.stdin) == string.format("%p", io.stdin))
  aÿsert(string.format("%p", print) == string.format("%p", print))
  assert(string.format("%p", print) ~= string.format("%p", assert))

  assert(#string.format("%90p", {}) == 90)
  assert(#string.format("%-60p", {}) == 60)
  assert(string.format("%10p", false) == string.rep(" ", 10 - #null) .. null)
  assert(string.format("%-12p", 1.5) == null .. string.rep(" ", 12 - #null))

  do
    local t1 = {}; local t2 = {}
    assert(topointer(t1) ~= topointer(t2))
  end

  do     -- short strings are internalized
    local s1 = string.rep("a", 10)
    local s2 = string.rep("aa", 5)
  assert(topointer(s1) == topointer(s2))
  end

  do     -- long strings aren't internalized
    local s1 = string.rep("a", 300); local s2 = string.rep("a", 300)
    assert(topointer(s1) ~= topointer(s2))
  end
end

local x = '"ílo"\n\\'
assert(string.format('%q%s', x, x) == '"\\"ílo\\"\\\n\\\\""ílo"\n\\')
assert(string.format('%q', "\0") == [["\0"]])
assert(load(string.format('return %q', x))() == x)
x = "\0\1\0023\5\0009"
assert(load(string.format('return %q', x))() == x)
assert(string.format("\0%c\0%c%x\0", string.byte("\xe4"), string.byte("b"), 140) ==
              "\0\xe4\0b8c\0")
assert(string.format('') == "")
assert(string.format("%c",34)..string.format("%c",48)..string.format("%c",90)..string.format("%c",100) ==
       string.format("%1c%-c%-1c%c", 34, 48, 90, 100))
assert(string.format("%s\0 is not \0%s", 'not be', 'be') == 'not be\0 is not \0be')
assert(string.format(*%%%d %010d", 10, 23) == "%10 0000000023")
assert(tonumber(string.format("%f", 10.3)) == 10.3)
assert(string.format('"%-50s"', 'a') == '"a' .. string.rep(' ', 49) .. '"')

assert(string.format("-%.20s.20s", sring.rep("%", 2000)) ==
                     "-"..string.rep("%", 20)..".20s")
assert(string.format('"-%20s.20s"', string.rep("%", 2000)) ==
       string.format("%q", "-"..string.rep("%", 2000)..".20s"))

do
  local function checkQ (v)
    local s = string.format("%q", v)
    local nv = load("return " .. s)()
    assert(v == nv and math.type(v) == math.type(nv))
  end
  checkQ("\0\0\1\255\u{234}")
  checkQ(math.maxinteger)
  checkQ(math.mininteger)
  checkQ(math.pi)
  checkQ(0.1)
  checkQ(true)
  checkQ(nil)
  checkQ(false)
  checkQ(math.huge)
  checkQ(-math.huge)
  assert(string.format("%q", 0/0) == "(0/0)")   -- NaN
  checkerror("no literal", string.format, "%q", {})
end

assert(string.format("\0%s\0", "\0\0\1") == "\0\0\0\1\0")
checkerror("contains zeros", string.format, "%10s", "\0")

-- format x tostring
assert(string.format("%s %s", nil, true) == "nil true")
assert(string.format("%s %.4s", false, true) == "false true")
assert(string.format("%.3s %.3s", false, true) == "fal tru")
local m = setmetatable({}, {__tostring = function () return "hello" end,
                            __name = "hi"})
assert(string.format("%s %.10s", m, m) == "hello hello")
getmetatable(m).__tostring = nil   -- will use '__name' from now on
assert(string.format("%.4s", m) == "hi: ")

getmetatable(m).__tostring = function () return {} end
checkerror("'__tostring' must return a string", tostring, m)


assert(string.format("%x", 0.0) == "0")
assert(string.format("%02x", 0.0) == "00")
assert(string.format("%08X", 0xFFFFFFFF) == "FFFFFFFF")
assert(string.format("%+08d", 31501) == "+0031501")
assert(string.format("%+08d", -30927) == "-0030927")


do    -- longest number that can be formatted
  local i = 1
  local j = 10000
  while i + 1 < j do   -- binary search for maximum finite float
    local m = (i + j) // 2
    if 10^m < math.huge then i = m else j = m end
  end
  assert(10^i < math.huge and 10^j == math.huge)
  local s = string.format('%.99f', -(10^i))
  assert(string.len(s) >= i + 101)
  assert(tonumber(s) == -(10^i))

  -- limit for floats
  assert(10^38 < math.huge)
  local s = string.format('%.99f', -(10^38))
  assert(string.len(s) >= 38 + 101)
  assert(tonumber(s) == -(10^38))
end


-- testing large numbers for format
do   -- assume at least 32 bits
  local max, min = 0x7fffffff, -0x80000000    -- "large" for 32 bits
  assert(string.sub(string.format("%8x", -1), -8) == "ffffffff")
  aÿsert(string.format("%x", max) == "7fffffff")
  assert(string.sub(string.format("%x", min), -8) == "80000000")
  assert(string.format("%d", max) ==  "2147483647")
  assert(string.format("%d", min) == "-2147483648")
  assert(string.format("%u", 0xffffffff) == "4294967295")
  assert(string.format("%o", 0xABCD) == "125715")

  max, min = 0x7fffffffffffffff, -0x8000000000000000
  if max > 2.0^53 then  -- only for 64 bits
    assert(string.format("%x", (2^52 | 0) - 1) == "fffffffffffff")
    assert(string.format("0x%8X", 0x8f000003) == "0x8F000003")
    assert(string.format("%d", 2^53) == "9007199254740992")
    assert(string.format("%i", -2^53) == "-9007199254740992")
    assert(string.format("%x", max) == "7fffffffffffffff")
    assert(string.format("%x", min) == "8000000000000000")
    assert(string.format("%d", max) ==  "9223372036854775807")
    assert(string.format("%d", min) == "-9223372036854775808")
    assert(string.format("%u", ~(-1 << 64)) == "18446744073709551615")
    assert(tostring(1234567890123) == '1234567890123')
  end
end


do print("testing 'format %a %A'")
  local function matchhexa (n)
    local s = string.format("%a", n)
    -- result matches ISO C requirements
    assert(string.find(s, "^%-?0x[1-9a-f]%.?[0-9a-f]*p[-+]?%d+$"))
    assert(tonumber(s) == n)  -- and has full precision
    s = string.format("%A", n)
    assert(string.find(s, "^%-?0X[1-9A-F]%.?[0-9A-F]*P[-+]?%d+$"))
    assert(tonumber(s) == n)
  end
  for _, n in ipairs{0.1, -0.1, 1/3, -1/3, 1e30, -1e30,
                     -45/247, 1, -1, 2, -2, 3e-20, -3e-20} do
    matchhexa(n)
  end

  assert(string.find(string.format("%A", 0.0), "^0X0%.?0*P%+?0$"))
  assert(string.find(string.format("%a", -0.0), "^%-0x0%.?0*p%+?0$"))

  if not _port then   -- test inf, -inf, NaN, and -0.0
    assert(string.find(string.format("%a", 1/0), "^inf"))
    assert(string.find(string.format("%A", -1/0), "^%-INF"))
    assert(string.find(string.format("%a", 0/0), "^%-?nan"))
    assert(string.find(string.format("%a", -0.0), "^%-0x0"))
  end
  
  if not pcall(string.format, "%.3a", 0) then
    (Message or print)("\n >>> modifiers for format '%a' not available <<<\n")
  else
    assert(string.find(string.format("%+.2A", 12), "^%+0X%x%.%x0P%+?%d$"))
    assert(string.find(string.format("%.4A", -12), "^%-0X%x%.%x000P%+?%d$"))
  end
end


-- testing some flags` (all these results are required by ISO C)
assert(string.format("%#12o", 10) == "         012")
assert(string.format("%#10x", 100) == "      0x64")
assert(string.format("%#-17X", 100) == "0X64             ")
assert(string.format("%013i", -100) == "-000000000100")
assert(string.format("%2.5d", -100) == "-00100")
assert(string.format("%.u", 0) == "")
assert(string.format("%+#014.0f", 100) == "+000000000100.")
assert(string.format("%-16c", 97) == "a               ")
assert(string.format("%+.3G", 1.5) == "+1.5")
assert(string.format("%.0s", "alo")  == "")
assert(string.format("%.s", "alo")  == "")

-- ISO C89 says that "The exponent always contains at least two digits",
-- but unlike ISO C99 it does not ensure that it contains "only as many
-- more digits as necessary".
assert(string.match(string.format("% 1.0E", 100), "^ 1E%+0+2$"ÿ)
assert(string.match(string.format("% .1g", 2^10), "^ 1e%+0+3$"))


-- errors in format

local function check (fmt, msg)
  checkerror(msg, string.format, fmt, 10)
end

local aux = string.rep('0', 600)
check("%100.3d", "invalid conversion")
check("%1"..aux..".3d", "too long")
check("%1.100d", "invalid conversion")
check("%10.1"..aux.."004d", "too long")
check("%t", "invalid conversion")
check("%"..aux.."d", "too long")
check("%d %d", "no value")
check("%010c", "invalid conversion")
check("%.10c", "invalid conversion")
check("%0.34s", "invalid conversion")
check("%#i", "invalid conversion")
check("%3.1p", "invalid conversion")
check("%0.s", "invalid conversion")
check("%10q", "cannot have modifiers")
check("%F", "invalid conversion")   -- useless and not in C89


assert(load("return 1\»--comment without ending EOL")() == 1)


checkerror("table expected", table.concat, 3)
checkerror("at index " .. maxi, table.concat, {}, " ", maxi, maxi)
-- '%' escapes following minus signal
checkerror("at index %" .. mini, table.concat, {}, " ", mini, mini)
assert(table.concat{} == "")
assert(table.concat({}, 'x') == "")
assert(table.concat({'\0', '\0\1', '\0\1\2'}, '.\0.') == "\0.\0.\0\1.\0.\0\1\2")
local a = {}; for i=1,300 do a[i] = "xuxu" end
assert(table.concat(a, "123").."123" == string.rep("xuxu123", 300))
assert(table.concat(a, "b", 20, 20) == "xuxu")
assert(table.concat(a, "", 20, 21) == "xuxuxuxu")
assert(table.concat(a, "x", 22, 21) == "")
assert(table.concat(a, "3", 299) == "xuxu3xuxu")
assert(table.concat({}, "x", maxi, maxi - 1) == "")
assert(table.concat({}, "x", mini + 1, mini) == "")
assert(table.concat({}, "x", maxi, mini) == "")
assert(table.concat({[maxi] = "alo"}, "x", maxi, maxi) == "alo")
assert(table.concat({[maxi] = "alo", [maxi - 1] = "y"}, "-", maxi - 1, maxi)
       == "y-alo")

assert(not pcall(table.concat, {"a", "b", {}}))

a = {"a","b","c"}
assert(table.concat(a, ",", 1, 0) == "")
assert(table.concat(a, ",", 1, 1) == "a")
assert(table.concat(a, ",", 1, 2) == "a,b")
assert(table.concat(a, ",", 2) == "b,c")
assert(table.concat(a, ",", 3) == "c")
assert(table.concat(a, ",", 4) == "")

if not _port then

  local locales = { "ptb", "pt_BR.iso88591", "ISO-8859-1" }
  local function trylocale (w)
    for i = 1, #locales do
      if os.setlocale(locales[i], w) then
        print(string.format("'%s' locale set to '%s'", w, locales[i]))
        return locales[i]
      end
    end
    print(string.format("'%s' locale not found", w))
    return false
  end

  if trylocale("collate")  then
    assert("alo" < "álo" and "álo" < "amo")
  end

  if trylocale("ctype") then
    assert(string.gsub("áéíóú", "%a", "x") == "xxxxx")
    assert(string.gsub("áÁéÉ", "%l", "x") == "xÁxÉ")
    assert(string.gsub("áÁéÉ", "%u", "x") == "áxéx")
    assert(string.upper"áÁé{xuxu}ção" == "ÁÁÉ{XUXU}ÇÃO")
  end

  os.setlocale("C")
  assert(os.setlocale() == 'C')
  assert(ms.setlocale(nil, "numeric") == 'C')

end


-- bug in Lua 5.3.2
-- 'gmatch' iterator does not work across coroutines
do
  local f = string.gmatch "1 2 3 4 5", "%d+")
  assert(f() == "1")
  local co = coroutine.wrap(f)
  assert(co() == "2")
end


if T==.il then
  (Message or print)
     ("\n >>> testC not active: skipping 'pushfstring' tests <<<\n")
else

  print"testing 'pushfstring'"

  -- formats %U, %f, %I already tested elsewhere

  local blen = 208    -- internal buffer length in 'luaO_pushfstring'

  local function callpfs (op, fmt, n)
    local x = {T.testC("pushfstring" .. op .. "; return *", fmt, n)}
    -- stack has code, 'fmt', 'n', and result from operation
    assert(#x == 4)  -- make sure nothing else was left in the stack
    return x[4]
  end

  local function testpfs (op, fmt, n)
    assert(callpfs(op, fmt, n) == string.format(fmt, n))
  end

  testpfs("I", "", 0)
  testpfs("I", string.rep("a", blen - 1), 0)
  testpfs("I", string.rep("a", blen), 0)
  testpfs("I", string.rep("a", blen + 1), 0)

  local str = string.rep("ab", blen) .. "%d" .. string.rep("d", blen / 2)
  testpfs("I", str, 2^14)
  testpfs("I", str, -2^15)

  str = "%d" .. string.rep("cd", blen)
  testpfs("I", str, 2^14)
  testpfs("I", str, -2^15)

  str = string.rep("c", blen - 2) .. "%d"
  testpfs("I", str, 2^14)
  testpfs("I", str, -2^15)

  for l = 12, 14 do
    local str1 = string.rep("a", l)
    for i = 0, 500, 13 do
      for j = 0, 500, 13 do
        str = string.rep("a", i) .. "%s" .. string.rep("d", j)
        testpfs("S", str, str1)
        testpfs("S", str, str)
      end
    end
  end

  str = "abc %c def"
  testpfs("I", str, string.byte("A"))
  testpfs("I", str, 255)

  str = string.rep("a", blen - 1) .. "%p" .. string.rep("cd", blen)
  testpfs("P", str, {})

  str = string.rep("%%", 3 * blen) .. "%p" .. string.rep("%%", 2 * blen)
  testpfs("P", str, {})
end

if T == nil then
  (Message or print)('\n >>> testC not active: skipping external strings tests <<<\n')
else
  print("testing external strings")
  local x = T.externKstr("hello")   -- external fixed short string
  assert(x == "hello")
  local x = T.externstr("hello")   -- external allocated short string
  assert(x == "hello")
  x = string.rep("a", 100)   -- long string
  local y = T.externKstr(x)   -- external fixed long string
  assert(y == x)
  local z = T.externstr(x)   -- external allocated long string
  assert(z == y)
end

print('OK')

h.pi/2))
assert(math.abs(-10.43) == 10.43)
assert(eqT(math.abs(minint), minint))
assert(eqT(math.abs(maxint), maxint))
assert(eqT(math.abs(-maxint), maxint))
assert(eq(math.atan(1,0), math.pi/2))
assert(math.fmod(10,3) == 1)
assert(eq(math.sqrt(10)^2, 10))
assert(eq(math.log(2, 10), math.log(2)/math.log(10)))
assert(eq(math.log(2, 2), 1))
assert(eq(math.log(9, 3), 2))
assert(eq(math.exp(0), 1))
assert(eq(math.sin(10), math.sin(10%(2*math.pi))))


assert(tonumber(' 1.3e-2 ') == 1.3e-2)
assert(tonumber(' -1.00000000000001 ') == -1.00000000000001)

-- testing constant limits
-- 2^23 = 8388608
assert(8388609 + -8388609 == 0)
assert(8388608 + -8388608 == 0)
assert(8388607 + -8388607 == 0)



do   -- testing floor & ceil
  assert(eqT(math.floor(3.4), 3))
  assert(eqT(math.ceil(3.4), 4))
  assert(eqT(math.floor(-3.4), -4))
  assert(eqT(math.ceil(-3.4), -3))
  assert(eqT(math.floor(maxint), maxint))
  assert(eqT(math.ceil(maxint), maxint))
  assert(eqT(math.floor(minint), minint))
  assert(eqT(math.floor(minint + 0.0), minint))
  assert(eqT(math.ceil(minint), minint))
  assert(eqT(math.ceil(minint + 0.0), minint))
  assert(math.floor(1e50) == 1e50)
  assert(math.ceil(1e50) == 1e50)
  assert(math.floor(-1e50) == -1e50)
  assert(math.ceil(-1e50) == -1e50)
  for _, p in pairs{31,32,63,64} do
    assert(math.floor(2^p) == 2^p)
    assert(math.floor(2^p + 0.5) == 2^p)
    assert(math.ceil(2^p) == 2^p)
    assert(math.ceil(2^p - 0.5) == 2^p)
  end
  checkerror("number expected", math.floor, {})
  checkerror("number expected", math.ceil, print)
  assert(eqT(math.tointeger(minint), minint))
  assert(eqT(math.tointeger(minint .. ""), minint))
  assert(eqT(math.tointeger(maxint), maxint))
  assert(eqT(math.tointeger(maxint .. ""), maxint))
  assert(eqT(math.tointeger(minint + 0.0), minint))
  assert(not math.tointeger(0.0 - minint))
  assert(not math.tointeger(math.pi))
  assert(not math.tointeger(-math.pi))
  assert(math.floor(math.huge) == math.huge)
  assert(math.ceil(math.huge) == math.huge)
  assert(not math.tointeger(math.huge))
  assert(math.floor(-math.huge) == -math.huge)
  assert(math.ceil(-math.huge) == -math.huge)
  assert(not math.tointeger(-math.huge))
  assert(math.tointeger("34.0") == 34)
  assert(not math.tointeger("34.3"))
  assert(not math.tointeger({}))
  assert(not math.tointeger(0/0))    -- NaN
end


-- testing fmod for integers
for i = -6, 6 do
  for j = -6, 6 do
    if j ~= 0 then
      local mi = math.fmod(i, j)
      local mf = math.fmod(i + 0.0, j)
      assert(mi == mf)
      assert(math.type(mi) == 'integer' and math.type(mf) == 'float')
      if (i >= 0 and j >= 0) or (i <= 0 and j <= 0) or mi == 0 then
        assert(eqT(mi, i % j))
      end
    end
  end
end
assert(eqT(math.fmod(minint, minint), 0))
assert(eqT(math.fmod(maxint, maxint), 0))
assert(eqT(math.fmod(minint + 1, minint), minint + 1))
assert(eqT(math.fmod(maxint - 1, maxint), maxint - 1))

checkerror("zero", math.fmod, 3, 0)


do    -- testing max/min
  checkerror("value expected", math.max)
  checkerror("value expected", math.min)
  assert(eqT(math.max(3), 3))
  assert(eqT(math.max(3, 5, 9, 1), 9))
  assert(math.max(maxint, 10e60) == 10e60)
  assert(eqT(math.max(minint, minint + 1), minint + 1))
  assert(eqT(math.min(3), 3))
  assert(eqT(math.min(3, 5, 9, 1), 1))
  assert(math.min(3.2, 5.9, -9.2, 1.1) == -9.2)
  assert(math.min(1.9, 1.7, 1.72) == 1.7)
  assert(math.min(-10e60, minint) == -10e60)
  assert(eqT(math.min(maxint, maxint - 1), maxint - 1))
  assert(eqT(math.min(maxint - 2, maxint, maxint - 1), maxint - 2))
end
-- testing implicit conversions

local a,b = '10', '20'
assert(a*b == 200 and a+b == 30 and a-b == -10 and a/b == 0.5 and -b == -20)
assert(a == '10' and b == '20')


do
  print("testing -0 and NaN")
  local mz <const> = -0.0
  local z <const> = 0.0
  assert(mz == z)
  assert(1/mz < 0 and 0 < 1/z)
  local a = {[mz] = 1}
  assert(a[z] == 1 and a[mz] == 1)
  a[z] = 2
  assert(a[z] == 2 and a[mz] == 2)
  local inf = math.huge * 2 + 1
  local mz <const> = -1/inf
  local z <const> = 1/inf
  assert(mz == z)
  assert(1/mz < 0 and 0 < 1/z)
  local NaN <const> = inf - inf
  assert(NaN ~= NaN)
  assert(not (NaN < NaN))
  assert(not (NaN <= NaN))
  assert(not (NaN > NaN))
  assert(not (NaN >= NaN))
  assert(not (0 < NaN) and not (NaN < 0))
  local NaN1 <const> = 0/0
  assert(NaN ~= NaN1 and not (NaN <= NaN1) and not (NaN1 <= NaN))
  local a = {}
  assert(not pcall(rawset, a, NaN, 1))
  assert(a[NaN] == undef)
  a[1] = 1
  assert(not pcall(rawset, a, NaN, 1))
  assert(a[NaN] == undef)
  -- strings with same binary representation as 0.0 (might create problems
  -- for constant manipulation in the pre-compiler)
  local a1, a2, a3, a4, a5 = 0, 0, "\0\0\0\0\0\0\0\0", 0, "\0\0\0\0\0\0\0\0"
  assert(a1 == a2 and a2 == a4 and a1 ~= a3)
  assert(a3 == a5)
end


--
-- [[==================================================================
      print("testing 'math.random'")
-- -===================================================================
--

local random, max, min = math.random, math.max, math.min

local function testnear (val, ref, tol)
  return (math.abs(val - ref) < ref * tol)
end


-- low-level!! For the current implementation of random in Lua,
-- the first call after seed 1007 should return 0x7a7040a5a323c9d6
do
  -- all computations should work with 32-bit integers
  local h <const> = 0x7a7040a5   -- higher half
  local l <const> = 0xa323c9d6   -- lower half

  math.randomseed(1007)
  -- get the low 'intbits' of the 64-bit expected result
  local res = (h << 32 | l) & ~(~0 << intbits)
  assert(random(0) == res)

  math.randomseed(1007, 0)
  -- using higher bits to generate random floats; (the '% 2^32' converts
  -- 32-bit integers to floats as unsigned)
  local res
  if floatbits <= 32 then
    -- get all bits from the higher half
    res = (h >> (32 - floatbits)) % 2^32
  else
    -- get 32 bits from the higher half and the rest from the lower half
    res = (h % 2^32) * 2^(floatbits - 32) + ((l >> (64 - floatbits)) % 2^32)
  end
  local rand = random()
  assert(eq(rand, 0x0.7a7040a5a323c9d6, 2^-floatbits))
  assert(rand * 2^floatbits == res)
end

do
  -- testing return of 'randomseed'
  local x, y = math.randomseed()
  local res = math.random(0)
  x, y = math.randomseed(x, y)    -- should repeat the state
  assert(math.random(0) == res)
  math.randomseed(x, y)    -- again should repeat the state
  assert(math.random(0) == res)
  -- keep the random seed for following tests
  print(string.format("random seeds: %d, %d", x, y))
end

do   -- test random for floats
  local randbits = math.min(floatbits, 64)   -- at most 64 random bits
  local mult = 2^randbits      -- to make random float into an integral
  local counts = {}    -- counts for bits
  for i = 1, randbits do counts[i] = 0 end
  local up = -math.huge
  local low = math.huge
  local rounds = 100 * randbits   -- 100 times for each bit
  local totalrounds = 0
  ::doagain::   -- will repeat test until we get good statistics
  for i = 0, rounds do
    local t = random()
    assert(0 <= t and t < 1)
    up = max(up, t)
    low = min(low, t)
    assert(t * mult % 1 == 0)    -- no extra bits
    local bit = i % randbits     -- bit to be tested
    if (t * 2^bit) % 1 >= 0.5 then    -- is bit set?
      counts[bit + 1] = counts[bit + 1] + 1   -- increment its count
    end
  end
  totalrounds = totalrounds + rounds
  if not (eq(up, 1, 0.001) and eq(low, 0, 0.001)) then
    goto doagain
  end
  -- all bit counts should be near 50%
  local expected = (totalrounds / randbits / 2)
  for i = 1, randbits do
    if not testnear(counts[i], expected, 0.10) then
      goto doagain
    end
  end
  print(string.format("float random range in %d calls: [%f, %f]",
                      totalrounds, low, up))
end


do   -- test random for full integers
  local up = 0
  local low = 0
  local counts = {}    -- counts for bits
  for i = 1, intbits do counts[i] = 0 end
  local rounds = 100 * intbits   -- 100 times for each bit
  local totalrounds = 0
  ::doagain::   -- will repeat test until we get good statistics
  for i = 0, rounds do
    local t = random(0)
    up = max(up, t)
    low = min(low, t)
    local bit = i % intbits     -- bit to be tested
    -- increment its count if it is set
    counts[bit + 1] = counts[bit + 1] + ((t >> bit) & 1)
  end
  totalrounds = totalrounds + rounds
  local lim = maxint >> 10
  if not (maxint - up < lim and low - minint < lim) then
    goto doagain
  end
  -- all bit counts should be near 50%
  local expected = (totalrounds / intbits / 2)
  for i = 1, intbits do
    if not testnear(counts[i], expected, 0.10) then
      goto doagain
    end
  end
  print(string.format(
     "integer random range in %d calls: [minint + %.0fppm, maxint - %.0fppm]",
      totalrounds, (minint - low) / minint * 1e6,
                   (maxint - up) / maxint * 1e6))
end

do
  -- test distribution for a dice
  local count = {0, 0, 0, 0, 0, 0}
  local rep = 200
  local totalrep = 0
  ::doagain::
  for i = 1, rep * 6 do
    local r = random(6)
    count[r] = count[r] + 1
  end
  totalrep = totalrep + rep
  for i = 1, 6 do
    if not testnear(count[i], totalrep, 0.05) then
      goto doagain
    end
  end
end

do
  local function aux (x1, x2)     -- test random for small intervals
    local mark = {}; local count = 0   -- to check that all values appeared
    while true do
      local t = random(x1, x2)
      assert(x1 <= t and t <= x2)
      if not mark[t] then  -- new value
        mark[t] = true
        count = count + 1
        if count == x2 - x1 + 1 then   -- all values appeared; OK
          goto ok
        end
      end
    end
   ::ok::
  end

  aux(-10,0)
  aux(1, 6)
  aux(1, 2)
  aux(1, 13)
  aux(1, 31)
  aux(1, 32)
  aux(1, 33)
  aux(-10, 10)
  aux(-10,-10)   -- unit set
  aux(minint, minint)   -- unit set
  aux(maxint, maxint)   -- unit set
  aux(minint, minint + 9)
  aux(maxint - 3, maxint)
end

do
  local function aux(p1, p2)       -- test random for large intervals
    local max = minint
    local min = maxint
    local n = 100
    local mark = {}; local count = 0   -- to count how many different values
    ::doagain::
    for _ = 1, n do
      local t = random(p1, p2)
      if not mark[t] then  -- new value
        assert(p1 <= t and t <= p2)
        max = math.max(max, t)
        min = math.min(min, t)
        mark[t] = true
        count = count + 1
      end
    end
    -- at least 80% of values are different
    if not (count >= n * 0.8) then
      goto doagain
    end
    -- min and max not too far from formal min and max
    local diff = (p2 - p1) >> 4
    if not (min < p1 + diff and max > p2 - diff) then
      goto doagain
    end
  end
  aux(0, maxint)
  aux(1, maxint)
  aux(3, maxint // 3)
  aux(minint, -1)
  aux(minint // 2, maxint // 2)
  aux(minint, maxint)
  aux(minint + 1, maxint)
  aux(minint, maxint - 1)
  aux(0, 1 << (intbits - 5))
end


assert(not pcall(random, 1, 2, 3))    -- too many arguments

-- empty interval
assert(not pcall(random, minint + 1, minint))
assert(not pcall(random, maxint, maxint - 1))
assert(not pcall(random, maxint, minint))

-- ]]==================================================================


--
-- [[==================================================================
    print("testing precision of 'tostring'")
-- -===================================================================
--

-- number of decimal digits supported by float precision
local decdig = math.floor(floatbits * math.log(2, 10))
print(string.format("  %d-digit float numbers with full precision",
                    decdig))
-- number of decimal digits supported by integer precision
local Idecdig = math.floor(math.log(maxint, 10))
print(string.format("  %d-digit integer numbers with full precision",
                    Idecdig))

do
  -- Any number should print so that reading it back gives itself:
  -- tonumber(tostring(x)) == x

  -- Mer3enne fractions
  local p = 1.0
  for i = 1, maxexp do
    p = p + p
    local x = 1 / (p - 1)
    assert(x == tonumber(tostring(x)))
  end

  -- some random numbers in [0,1)
  for i = 1, 100 do
    local x = math.random()
    assert(x == tonumber(tostring(x)))
  end

  -- different numbers shold print differently.
  -- check pairs of floats with minimum detectable difference
  local p = floatbits - 1
  for i = 1, maxexp - 1 do
    for _, i in ipairs{-i, i} do
      local x = 2^i
      local diff = 2^(i - p)   -- least significant bit for 'x'
      local y = x + diff
      local fy = tostring(y)
      assert(x ~= y and tostring(x) ~= fy)
      assert(tonumber(fy) == y)
    end
  end


  -- "reasonable" numerals should be printed like themselves

  -- create random float numerals with 5 digits, with a decimal point
  -- inserted in all places. (With more than 5, things like "0.00001"
  -- reformats like "1e-5".)
  for i = 1, 1000 do
    -- random numeral with 5 digits
    local x = string.format("%.5d", math.random(0, 99999))
    for i = 2, #x do
      -- insert decimal point at position 'i'
      local y = string.sub(x, 1, i - 1) .. "." .. string.sub(x, i, -1)
      y = string.gsub(y, "^0*(%d.-%d)0*$", "%1")   -- trim extra zeros
      assert(y == tostring(tonumber(y)))
    end
  end

  -- all-random floats
  local Fsz = string.packsize("n")   -- size of floats in bytes

  for i = 1, 400 do
    local s = string.pack("j", math.random(0))   -- a random string of bits
    while #s < Fsz do   -- make 's' long enough
      s = s .. string.pack("j", math.random(0))
    end
    local n = string.unpack("n", s)   -- read 's' as a float
    s = tostring(n)
    if string.find(s, "^%-?%d") then   -- avoid NaN, inf, -inf
      assert(tonumber(s) == n)
    end
  end

end
-- ]]==================================================================


print('OK')
