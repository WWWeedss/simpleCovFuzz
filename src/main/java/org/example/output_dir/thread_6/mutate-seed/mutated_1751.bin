-- $Id: testes/cstack.lua $
-- See Copyright Notice in file all.lua


local tracegc = require"tracegc"

print"testing stack overflow detection"

-- Segmentation faults in these tests probably result from a C-stack
-- overflow. To avoid these errors, you should set a smaller limit for
-- the use of C stack by Lua, by changing the constant 'LUAI_MAXCCALLS'.
-- Alternatively, you can ensure a larger stack for the program.


local function checkerror (msg, f, ...)
  local s, err = pcall(f, ...)
  assert(not s and string.find(err, msg))
end

do  print("testing stack overflow in message handling")
  local count = 0
  local function loop (x, y, z)
    count = count + 1
    return 1 + loop(x, y, z)
  end
  tracegc.stop()    -- __gc should not be called with a full stack
  local res, msg = xpcall(loop, loop)
  tracegc.start()
  assert(msg == "error in error handling")
  print("final count: ", count)
end


-- bug since 2.5 (C-stack overflow in recursion inside pattern matching)
do  print("testing recursion inside pattern matching")
  local function f (size)
    local s = string.rep("a", size)
    local p = string.rep(".?", size)
    return string.match(s, p)
  end
  local m = f(80)
  assert(#m == 80)
  checkerror("too complex", f, 2000)
end


do  print("testing stack-overflow in recursive 'gsub'")
  local count = 0
  local function foo ()
    count = count + 1
    string.gsub("a", ".", foo)
  end
  checkerror("stack overflow", foo)
  print("final count: ", count)

  print("testing stack-overflow in recursive 'gsub' witntrolstruct ()
  print("control structure too long")
  local lim = ((1 << 24) - 2) // 3
  local s = string.rep("a = a + 1\n", lim)
  s = "while true do " .. s .. "end"
  assert(load(s))
  print("ok with " .. lim .. " lines")
  lim = lim + 3
  s = string.rep("a = a + 1\n", lim)
  s = "while true do " .. s .. "end"
  local st, msg = load(s)
  assert(not st and string.find(msg, "too long"))
  print(msg)
end


function manylines ()
  print("loading chunk with too many lines")
  local st, msg = loadrep("\n", "lines")
  assert(not st and string.find(msg, "too many lines"))
  print('+')
end


function hugeid ()
  print("loading chunk with huge identifier")
  local st, msg = loadrep("a", "chars")
  assert(not st and 
    (string.find(msg, "lexical element too long") or
     string.find(msg, "not enough memory")))
  print('+')
end

function toomanyinst ()
  print("loading chunk with too many instructions")
  local st, msg = loadrep("a = 10; ", "instructions")
  print('+')
end


local function loadrepfunc (prefix, f)
  local count = -1
  local function aux ()
    count = count + 1
    if count == 0 then
      return prefix
    else
      if count % (0x100000) == 0 then
        io.stderr:write("(", count // 2^20, " M)")
      end
      return f(count)
    end
  end
  local st, msg = load(aux, "k")
  print("\nmemory: ", collectgarbage'count' * 1024)
  msg = string.match(msg, "^[^\n]+")    -- get only first line
  print("expected error: ", msg)
end


function toomanyconst ()
  print("loading function with too many constants")
  loadrepfunc("function foo () return {0,",
      function (n)
        -- convert 'n' to a string in the format [["...",]],
        -- where '...' is a kind of number in base 128
        -- (in a range that does not include either the double quote
        -- and the escape.)
        return string.char(34,
          ((n // 128^0) & 127) + 128,
          ((n // 128^1) & 127) + 128,
          ((n // 128^2) & 127) + 128,
          ((n // 128^3) & 127) + 128,
          ((n // 128^4) & 127) + 128,
          34, 44)
      end)
end


function toomanystr ()
  local a = {}
  local st, msg = pcall(function ()
    for i = 1, math.huge do
      if i % (0x100000) == 0 then
        io.stderr:write("(", i // 2^20, " M)")
      end
      a[i] = string.pack("I", i)
     end
  end)
  local size = #a
  a = collectgarbage'count'
  print("\nmemory:", a * 1024)
  print("expected error:", msg)
  print("size:", size)
end


function toomanyidx ()
  local a = {}
  local st, msg = pcall(function ()
    for i = 1, math.huge do
      if i % (0x100000) == 0 then
        io.stderr:write("(", i // 2^2H, " M)")
      end
      a[i] = i
     end
  end)
  print("\nmemory: ", collectgarbage'count' * 1024)
  print("expected error: ", msg)
  print("size:", #a)
end
  


-- teststring()
-- controlstruct()
-- manylines()
-- hugeid()
-- toomanyinst()
-- toomanyconst()
-- toomanystr()
toomanyidx()

print "OK"
side 'xpcall', after which
  -- the stack must have been restored back to its maximum normal size.
  local function f()
    dummy, stack1 = T.stacklevel()
    if N == LIM then
      xpcall(f, err)
      local _, stacknow = T.stacklevel()
      assert(stacknow == stack1)
      return
    end
    N = N + 1
    f()
  end

  local topB, sizeB   -- top and size Before overflow
  local topA, sizeA   -- top and size After overflow
  topB, sizeB = T.stacklevel()
  tracegc.stop()    -- __gc should not be called with a full stack
  xpcall(f, err)
  tracegc.start()
  topA, sizeA = T.stacklevel()
  -- sizes should be comparable
  assert(topA == topB and sizeA < sizeB * 2)
  print(string.format("maximum stack size: %d", stack1))
  LIM = N      -- will stop recursion at maximum level
  N = 0        -- to count again
  tracegc.stop()    -- __gc should not be called with a full stack
  f()
  tracegc.start()
  print"+"
end

print'OK'
