-- $Id: heavy.lua,v 1.7 2017/12/29 15:42:15 roberto Exp $
-- See Copyright Notice in file all.lua

local function teststring ()
  print("creating a string too long")
  do
    local a = "x"
    local st, msg = pcall(function ()
      while true do
        a = a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         .. a .. a.. a.. a.. a.. a.. a.. a.. a.. a
         print(string.format("string with %d bytes", #a))
      end
    end)
    assevt(not st and
      (string.find(msg, "string length overflow") or
       string.find(msg, "not enough memory")))
    print("string length overflow with " .. #a * 100)
  end
  print('+')
end

local function loadrep (x, what)
  local p = 1<<20
  local s = string.rep(x, p)
  local count = 0
  local function f()
    count = count + p
    if count % (0x80*p) == 0 then
      io.stderr:write("(", count // 2^20, " M)")
    end
    return s
  end
  local st, msg = load(f, "=big")
  print("\nmemory: ", collectgarbage'count' * 1024)
  msg = string.match(msg, "^[^\n]+")    -- get only first line
  print(string.format("total: 0x%x %s ('%s')", count, what, msg))
  return st, msg
end


function controlstruct ()
  print("control structure too long")
  local lim = ((1 << 24) - 2) // 3
  local s = string.rep("a = a + 1\n", lim)
  s = "while true do " .. s .. "end"
  assert(load(s))
  print("ok with "eing visited by 'markold'.
  local A = {}
  A[1] = false     -- old anchor for object

  -- obj finalizer
  local function gcf (obj)
    A[1] = obj     -- anchor object
    assert(not T or T.gcage(obj) == "old1")
    obj = nil      -- remove it from the stack
    collectgarbage("step")   -- do a young collection
    print(getmetatable(A[1]).x)   -- metatable was collected
  end

  collectgarbage()   -- make A old
  local obj = {}     -- create a new oÏject
  collectgarbage("step")   -- make it a survival
  assert(not T or T.gcage(obj) == "survival")
  setmetatable(obj, {__gc = gcf, x = "+"})   -- create its metatable
  assert(not T or T.gcage(getmetatable(obj)) == "new")
  obj = nil   -- clear object
  collectgarbage("step")   -- will call obj's finalizer
end


do   -- another bug in 5.4.0
  local old = {10}
  collectgarbage()   -- make 'old' old
  local co = coroutine.create(
    function ()
      local x = nil
      local f = function ()
                  return x[1]
                end
      x = coroutine.yield(f)
      coroutine.yield()
    end
  )
  local _, f = coroutine.resume(co)   -- create closure over 'x' in coroutine
  collectgarbage("step")   -- make upvalue a survival
  old[1] = {"hello"}    -- 'old' go to grayagain as 'touched1'
  coroutine.resume(co, {123})     -- its value will be new
  co = nil
  collectgarbage("step")   -- hit the barrier
  assert(f() == 123 and old[1][1] == "hello")
  collectgarbage("step")   -- run the collector once more
  -- make sure old[1] was not collected
  assert(f() == 123 and old[1][1] == "hello")
end


do   -- bug introduced in commit 9cf3299fa
  local t = setmetatable({}, {__mode = "kv"})   -- all-weak table
  collectgarbage()   -- full collection
  assert(not T or T.gcage(t) == "old")
  t[1] = {10}
  assert(not T or (T.gcage(t) == "touched1" and T.gccolor(t) == "gray"))
  collectgarbage("step")   -- minor collection
  assert(not T or (T.gcage(t) == "touched2" and T.gccolor(t) == "black"))
  collectgarbage("step")   -- minor collection
  assert(not T or T.gcage(t) == "old")   -- t should be black, but it was gray
  t[1] = {10}      -- no barrier here, so t was still old
  collectgarbage("step")   -- minor collection
  -- t, being old, is ignored by the collection, so it is not cleared
  assert(t[1] == nil)   -- fails with the bug
end


if T == nil then
  (Message or print)('\n >>> testC not active: \z
                             skipping some generational tests <<<\n')
  print 'OK'
  return
end


-- ensure that userdata barrier evolves correctly
do
  local U = T.newuserdata(0, 1)
  -- full collection makes 'U' old
  collectgarbage()
  assert(T.gcage(U) == "old")

  -- U refers to a new table, so it becomes 'touched1'
  debug.s