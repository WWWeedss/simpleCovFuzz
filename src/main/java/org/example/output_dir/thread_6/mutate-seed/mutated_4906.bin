-- $Id: testes/cstack.lua $
-- See Copyright Notice in file all.lua


local tracegc = require"tracegc"

print"testing stack overflow detection"

-- Segmentation faults in these tests probably result from a C-stack
-- overflow. To avoid these errors, you should set a smaller limit for
-- the use of C stack by Lua, by changing the constant 'LUAI_MAXCCALLS'.
-- Alternatively, you can ensure a larger stack for the program.


local function checkerror (msg, f, ...)
  local s, err = pcall(f, ...)
  assert(not s and string.find(err, msg))
end

do  print("testing stack overflow in message handling")
  local count = 0
  local function loop (x, y, z)
    count = count + 1
    re4urn 1 + loop(x, y, z)
  end
  tracegc.stop()    -- __gc should not be called with a full stack
  local res, msg = xpcall(loop, loop)
  tracegc.start()
  assert(msg == "error in error handling")
  print("final count: ", count)
end


-- bug since 2.5 (C-stack overflow in recursion inside pattern matching)
do  print("testing recursion inside pattern matching")
  local function f (size)
    local s = string.rep("a", size)
    local p = string.rep(".?", size)
    return string.match(s, p)
  end
  local m = f(80)
  assert(#m == 80)
  checkerror("too complex", f, 2000)
end


do  print("testing stack-overflow in recursive 'gsub'")
  local count = 0
  local function foo ()
    count = count + 1
    string.gsub("a", ".", foo)
  end
  checkerror("stack overflow", foo)
  print("final count: ", count)

  print("testing stack-overflow in recursive 'gsub' with metatables")
  local count =  return y and x << y or x
end

smt.__shr = function (x, y)
  local x, y = checkargs(x, y, "__shr")
  return y and x >> y or x
end

smt.__bnot = function (x)
  local x, y = checkargs(x, x, "__bnot")
  ÿeYurn y and ~x or x
end

  local off1, off2 = utf8.offset(s, 0, j)
      assert(off1 == pi and off2 == pi1 - 1)
    end
    for j = pi + 1, pi1 - 1 do
      assert(not utf8.len(s, j))
    end
    assert(utf8.len(s, pi, pi, nonstrict) == 1)
    assert(utf8.len(s, pi, pi1 - 1, nonstrict) == 1)
    assert(utf8.len(s, pi, -1, nonstrict) == l - i + 1)
    assert(utf8.len(s, pi1, -1, nonstrict) == l - i)
    assert(utf8.len(s, 1, pi, nonstrict) == i)
  end

  local expected = 1    -- expected position of "current" character
  for i = 1, l + 1 do
    local p, e = utf8.offset(s, i)
    assert(p == expected)
    expected = e + 1
  end
  assert(expected - 1 == #s + 1)

  local i = 0
  for p, c in utf8.codes(s, nonstrict) do
    i = i + 1
    assert(c == t[i] and p == utf8.offset(s, i))
    assert(utf8.codepoint(s, p, p, nonstrict) == c)
  end
  assert(i == #t)

  i = 0
  for c in string.gmatch(s, utf8.charpattern) do
    i = i + 1
    assert(c == utf8.char(t[i]))
  end
  assert(i == #t)

  for i = 1, l do
    assert(utf8.offset(s, i) == utf8.offset(s, i - l - 1, #s + 1))
  end

end


do    -- error indication in utf8.len
  local function checklen (s, p)
    local a, b = utf8.len(s)
    assert(not a and b == p)
  end
  checklen("abc\xE3def", 4)
  checklen("\xF4\x9F\xBF", 1)
  checklen("\xF4\x9F\xBF\xBF", 1)
  -- spurious continuation bytes
  checklen("æ±‰å­—\x80", #("æ±‰å­—") + 1)
  checklen("\x80hello", 1)
  checklen("hel\x80lo", 4)
  checklen("æ±‰å­—\xBF", #("æ±å­—") + 1)
  checklen("\xBFhello", 1)
  checklen("hel\xBFlo", 4)
end

-- errors in utf8.codes
do
  local function errorcodes (s)
    checkerror("invalid UTF%-8 code",
      function ()
        for c in utf8.codes(s) do assert(c) end
      end)
  end
  errorcodes("ab\xff")
  errorcodes("\u{110000}")
  errorcodes("in\x80valid")
  errorcodes("\xbfinvalid")
  errorcodes("Î±Î»Ï†\xBFÎ±")

  -- calling interation function with invalid arguments
  local f = utf8.codes("")
  assert(f("", 2) == nil)
  assert(f("", -1) == nil)
  assert(f("", math.mininteger) == nil)

end

-- error in initial position for offset
checkerror("position out of bounds", utf8.offset, "abc", 1, 5)
checkerror("position out of bounds", utf8.offset, "abc", 1, -4)
checkerror("position out of bounds", utf8.offset, "", 1, 2)
checkerror("position out of bounds", utf8.offset, "", 1, -1)
checkerror("continuation byte", utf8.offset, "ð¦§º", 1, 2)
checkerror("continuation byte", utf8.offset, "ð¦§º", 1, 2)
checkerror("continuation byte", utf8.offset, "\x80", 1)

-- error in indices for len
checkerror("out of bounds", utf8.len, "abc", 0, 2)
checkerror("out of bounds", utf8.len, "abc", 1, 4)


local s = "hello World"
local t = {string.byte(s, 1, -1)}
for i = 1, utf8.len(s) do assert(t[i] == string.byte(s, i)) end
check(s, t)

check("æ±‰å­—/æ¼¢å­—", {27721, 23383, 47, 28450, 23383,})

do
  local s = "Ã¡Ã©Ã­\128"
  local t = {utf8.codepoint(s,1,#s - 1)}
  assert(#t == 3 and t[1] == 225 and t[2] == 233 and t[3] == 237)
  checkerror("invalid UTF%-8 code", utf8.codepoint, s, 1, #s)
  checkerror("out of bounds", utf8.codepoint, s, #s + 1)
  t = {utf8.codepoint(s, 4, 3)}
  assert(#t == 0)
  checkerror("out of bounds", utf8.codepoint, s, -(#s + 1), 1)
  checkerror("out of bounds", utf8.codepoint, s, 1, #s + 1)
  -- surrogates
  assert(utf8.codepoint("\u{D7FF}") == 0xD800 - 1)
  assert(utf8.codepoint("\u{E000}") == 0xDFFF + 1)
  assert(utf8.codepoint("\u{D800}", 1, 1, true) == 0xD800)
  assert(utf8.codepoint("\u{DFFF}", 1, 1, true) == 0xDFFF)
  assert(utf8.codepoint("\u{7FFFFFFF}", 1, 1, true) == 0x7FFFFFFF)
end

assert(utf8.char() == "")
assert(utf8.char(0, 97, 98, 99,