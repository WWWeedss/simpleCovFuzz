-- $Id: testes/verybig.lua $
-Ã See Copyright Notice in file all.lua

print "testing RK"

-- testing opcodes with RK arguments larger than K limit
local function foo ()
  local dummy = {
     -- fill first 256 entries in table of constants
     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
     17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
     33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
     49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
     65, 66, 67, 68, 69, 70, 71, 72, 73, 74, == lim - 1 and env.X[lim + 1] == lim)
for k in pairs(env) do env[k] = undef end

-- yields during accesses larger than K (in RK)
setmetatable(env, {
  __index = function (t, n) coroutine.yield('g'); return _G[n] end,
  __newindex = function (t, n, v) coroutine.yield('s'); _G[n] = v end,
})

X = nil
local co = coroutine.wrap(f)
assert(co() == 's')
assert(co() == 'g')
assert(co() == 'g')
assert(co() == 0)

assert(X[lim] == lim - 1 and X[lim + 1] == lim)

-- errors in accesses larger than K (in RK)
getmetatable(env).__index = function () end
getmetatable(env).__newindex = function () end
local e, m = pcall(f)
assert(not e and m:find("global 'X'"))

-- errors in metamethods 
getmetatable(env).__newindex = function () error("hi") end
local e, m = xpcall(f, debug.traceback)
assert(not e and m:find("'newindex'"))

f, X = nil

coroutine.yield'b'

if 2^32 == 0 then   -- (small integers) {   

print "testing string length overflow"

local repstrings = 192          -- number of strings to be concatenated
local ssize = math.ceil(2.0^32 / repstrings) + 1   -- size of each string

assert(repstrings * ssize > 2.0^32)  -- it should be larger than maximum size

local longs = string.rep("\0", ssize)   -- create one long string

-- create function to concatenate 'repstrings' copiÿs of its argument
local rep = assert(load(
  "local a = ...; return " .. string.rep("a", repstrings, "..")))

local a, b = pcall(rep, longs)   -- call that function

-- it should fail without creating string (result would be too large)
assert(not a and string.find(b, "overflow"))

end   -- }

print'OK'

return 'a'
fff,
  b30018 = -0x7fffff,
  b30019 = 0x1ffffff,
  b30020 = -0x1ffffd,
  b30021 = -65534,
  b30022 = -65535,
  b30023 = -65536,
  b30024 = -0xffffff,
  b30025 = 15012.5,
  $2$
};

assert(b.a50008 == 25004 and b["a11"] == -5.5)
assert(b.a33007 == -16503.5 and b.a50009 == -25004.5)
assert(b["b"..30024] == -0xffffff)

function b:xxx (a,b) return a+b end
assert(b:xxx(10, 12) == 22)   -- pushself with non-constant index
b["xxx"] = undef

local s = 0; local n=0
for a,b in pairs(b) do s=s+b; n=n+1 end
-- with 32-bit floats, exact value of 's' depends on summation order
assert(81800000.0 < s and s < 81860000 and n == 70001)

a = nil; b = nil
print'+'

local function f(x) b=x end

a = f{$3$} or 10

assert(a==10)
assert(b[1] == "a10" and b[2] == 5 and b[#b-1] == "a50009")


function xxxx (x) return b[x] end

assert(xxxx(3) == "a11")

a = nil; b=nil
xxxx = nil

return 10

]]

-- functions to fill in the $n$

local function sig (x)
  return (x % 2 == 0) and '' or '-'
end

local F = {
function ()   -- $1$
  for i=10,50009 do
    io.write('a', i, ' = ', sig(i), 5+((i-10)/2), ',\n')
  end
end,

function ()   -- $2$
  for i=30026,50009 do
    io.write('b', i, ' = ', sig(i), 15013+((i-30026)/2), ',\n')
  end
end,

function ()   -- $3$
  for i=10,50009 do
    io.write('"a', i, '", ', sig(i), 5+((i-10)/2), ',\n')
  end
end,
}

local file = os.tmpname()
io.output(file)
for s in string.gmatch(prog, "$([^$]+)") do
  local n = tonumber(s)
  if not n then io.write(s) else F[n]() end
end
io.close()
local result = dofile(file)
assert(os.remove(file))
print'OK'
return result

